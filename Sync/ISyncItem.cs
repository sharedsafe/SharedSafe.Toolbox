/**
	Alternatively reconcilation process may create a number of synchronization items.

	All synchronization items build a tree that is a mixture between the two input replicas
	The tree reflects 

	a) All the items involved
	b) All the states and jobs involved to bring the two trees together.
**/

using System;

namespace Toolbox.Sync
{
	public enum SyncItemState
	{
		/// Both items are perfectly in sync
		InSync,

		/// Some conflict
		Conflict,

		/// Items must be reconciled, the DominantIndex is set and specifies
		/// the prototype for all other items. If the prototype is null, all other items must be deleted.
		/// Items that are set and are not
		/// the dominant items must be deleted before reconcilation takes place.
		
		Reconcile,

		/// Items are reconciling right now, they wait for further confirmation.
		Reconciling,

		/// Items shall be merged
		NeedsMerge
	}

	public enum SyncItemSubState
	{
		#region InSync

		/// Nothing has changed.
		NoChange,

		/// Both items have been deleted
		Deleted,

		/// Items have been properly reconciled or merged!
		/// (note: the actual items are not changed, but the dominant item, the item having the
		/// ReconcileIndex set, hides all other items.
		Reconciled,

		/// Items have been merged and contain the same data.
		Merged,

		#endregion

		#region Conflict

		// One item is null
		ConflictUpdateDelete,
		/// Either generated by a transformation from (Merge,Merge) or by some late-detected errors.
		ConflictUpdateUpdate,

		#endregion

		#region Reconcile & Reconciling

		// Note: The reconcilation states are important to find out in which order
		// items may be processed!
	
		ReconcileCreate,
		ReconcileUpdate,
		ReconcileDelete,

		#endregion

		#region Merge
		NeedsMerge
		#endregion
	}

	public interface ISyncItem : IHierarchy<ISyncItem>
	{
		string Name { get; }

		/// The items of the two replicas involved in this job item.
		/// Note: may both be null!
		IItem[] Items { get; }

		#region Current state

		SyncItemState State { get; }
		SyncItemSubState SubState { get; }

		/// Substate backup after reconciled()
		SyncItemSubState SubStateReconciled { get; }

		/// The index of the item that is the prototype to Reconcile
		uint? ReconcileIndex { get; }

		/// Optional error that happens while this item was getting reconciled.
		Exception ReconcilationError_ { get; }

		#endregion

		#region Modification

		/// This item can not be resolved by a merge.
		void markMergeConflict();

		/// We tracked an error regarding the reconcilation of this item.
		void setReconcilationError(Exception e);

		/// This item has been successfully resolved by a merge.
		void merged(IItem mergedItem);

		/// Item is in a temporary state, it is currently reconciling, use reconciled() to confirm.
		void reconciling();

		/// Item has been successfully be reconciled (used only on Reconcile)
		void reconciled();

		/// A conflict shall be resolved by preferring the given indexed item.
		/// This leads to either ReconcileDelete or ReconcileUpdate
		void resolveConflict(uint index);

		#endregion


		/// Try to locate a nested item as fast as possible. Do not recurse, return null if
		/// the item with the name given is not found. string comparison is exact.
		ISyncItem tryLocate(string name);

		void add(ISyncItem nested);
	}
}
